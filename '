mod walls;
use walls::*;
use std::time::Duration;

use bevy::{prelude::*, sprite::{MaterialMesh2dBundle, Material2d, Mesh2dHandle}, diagnostic::{LogDiagnosticsPlugin, FrameTimeDiagnosticsPlugin}};
use bevy_rapier2d::{prelude::*};
use iyes_loopless::prelude::*;

const WALL_COLOR: Color = Color::rgb(0.8, 0.8, 0.8);
const BALL_COLOR: Color = Color::rgb(1.0, 0.5, 0.5);
const BACKGROUND_COLOR: Color = Color::rgb(0.9, 0.9, 0.9);
const WALL_THICKNESS: f32 = 10.0;
// x coordinates
const LEFT_WALL: f32 = -450.;
const RIGHT_WALL: f32 = 450.;
// y coordinates
const BOTTOM_WALL: f32 = -300.;
const TOP_WALL: f32 = 300.;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugin(RapierPhysicsPlugin::<NoUserData>::pixels_per_meter(40.0))
        .add_plugin(RapierDebugRenderPlugin::default())
        .add_plugin(LogDiagnosticsPlugin::default())
        .add_plugin(FrameTimeDiagnosticsPlugin::default())
        .insert_resource(ClearColor(BACKGROUND_COLOR))
        .insert_resource(Msaa { samples: 4})
        .add_startup_system(setup_graphics)
        .add_startup_system(setup_physics)
        // .add_system(weapon_system)
        .add_system(camera_system)
        .add_fixed_timestep(Duration::from_millis(17), "physics_timestep")
        .add_fixed_timestep_system("physics_timestep", 0, control_player)
        .add_fixed_timestep_system("physics_timestep", 0, jump_reset)

        .run();
}

fn setup_graphics(mut commands: Commands) {
    // Add a camera so we can see the debug-render.
    commands.spawn(Camera2dBundle::default());
}

fn setup_physics(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<ColorMaterial>>,
) {
    // commands
    //     .spawn(RigidBody::Dynamic)
    //     .insert(MaterialMesh2dBundle {
    //         mesh: meshes.add(shape::Circle::new(20.).into()).into(),
    //         material: materials.add(ColorMaterial::from(Color::hex("77567A").unwrap())),
    //         ..default()
    //     })
    //
    //     .insert(Collider::ball(20.0))
    //     .insert(Restitution::coefficient(0.0))
    //     .insert(ActiveEvents::COLLISION_EVENTS)
    //     .insert(Jumper { jump_impulse: 100., roll_impulse: 0.2, is_jumping: false, jump_multiplier: 1.})
    //     .insert(Player)
    //     .insert(Velocity {
    //         linvel: Vec2::new(0.0, 0.0),
    //         angvel: 0.2
    //     })
    //     .insert(Friction::coefficient(2.0))
    //     .insert(TransformBundle::from(Transform::from_xyz(0.0, 50.0, 0.0)))
    //     .insert(Weapon::new());
    commands.spawn(PlayerBundle::new(&mut meshes, &mut materials))
    .add_children(|parent| {
            parent.spawn(Weapon::new());
        })
    ;

    // commands
    //     .spawn(RigidBody::Dynamic)
    //     .insert(MaterialMesh2dBundle {
    //         mesh: meshes.add(shape::Circle::new(20.).into()).into(),
    //         material: materials.add(ColorMaterial::from(Color::hex("77567A").unwrap())),
    //         ..default()
    //     })
    //
    //     .insert(SpriteBundle {
    //         transform: Transform::from_xyz(0.,0.,2.),
    //         sprite: Sprite {
    //             color: Color::hex("E8CEE4").unwrap(),
    //             custom_size: Some(Vec2::new(20., 20.)),
    //             ..default()
    //         },
    //         ..default()
    //     })
    //     .insert(Collider::ball(20.0))
    //     .insert(Restitution::coefficient(0.0))
    //     .insert(ActiveEvents::COLLISION_EVENTS)
    //     .insert(Velocity {
    //         linvel: Vec2::new(0.0, 0.0),
    //         angvel: 0.2
    //     })
    //     .insert(Friction::coefficient(2.0))
    //     .insert(TransformBundle::from(Transform::from_xyz(-50., 50.0, 0.0)))
    //     .add_children(|parent| {
    //         parent.spawn(Weapon::new());
        // });    
    commands.spawn(WallBundle::new(WallLocation::Left));
    commands.spawn(WallBundle::new(WallLocation::Right));
    commands.spawn(WallBundle::new(WallLocation::Bottom));
    commands.spawn(WallBundle::new(WallLocation::Top));

}

fn jump_reset(
    mut query: Query<(Entity, &mut Jumper), With<Player>>,
    mut collision_events: EventReader<CollisionEvent>,
) {
    for e in collision_events.iter() {
        for (entity, mut jumper) in query.iter_mut() {
            jump_check(entity, &mut jumper, e);
        }
    }

}

fn jump_check(entity: Entity, jumper: &mut Jumper, event: &CollisionEvent) {
    if let CollisionEvent::Started(h1, h2, _) = event {
        if *h1 == entity || *h2 == entity {
            jumper.is_jumping = false;

        }
    }
}

fn control_player(
    keys: Res<Input<KeyCode>>,
    mut query: Query<(&mut Jumper, &mut Velocity), With<Player>>,
) {
    let   (mut jumper, mut velocity) = query.single_mut();
    if keys.just_released(KeyCode::Space) && !jumper.is_jumping {
        velocity.linvel.y += jumper.jump_impulse * jumper.jump_multiplier;
        jumper.is_jumping = true;
        jumper.jump_multiplier = 1.;
    }

    // we can check multiple at once with `.any_*`
    if keys.pressed(KeyCode::A) {

        velocity.angvel += jumper.roll_impulse;

        if jumper.is_jumping && velocity.linvel.x > -100.{
            velocity.linvel.x -= 3.;
        }

    }

    if keys.pressed(KeyCode::D) {

        velocity.angvel -= jumper.roll_impulse;

        if jumper.is_jumping && velocity.linvel.x < 100. {
            velocity.linvel.x += 3.;
        }
    }    if keys.pressed(KeyCode::Space) {

        velocity.angvel = 0.0;
        if velocity.linvel.x.abs() < 2. {
            jumper.jump_multiplier = 1.
        } else if jumper.jump_multiplier <= 1.6 {
            jumper.jump_multiplier += 0.01;
        }
    }

}

fn camera_system(
    mut camq: Query<( &mut Transform, With<Camera2d> ), Without<Player>>,
    // playerq: Query<( &Transform, With<Player> ), Without<Camera2d>>,
    playerq: Query<( &Transform, With<Player> ), Without<Camera2d>>,

    mut commands:Commands
) {

    let mut cam = camq.get_single_mut().unwrap();
    let transform = playerq.get_single().unwrap();
    cam.0.translation.x = transform.0.translation.x;
    cam.0.translation.y = transform.0.translation.y + 200.;
}

// fn weapon_system(
//     mut weapq: Query<( &mut Weapon), With<Parent>>,
//     mut playerq: Query<(( &Transform), With<Player>), Without<Weapon>>
// ) {
//     let  (mut weap) = weapq.single_mut();
//     let player = playerq.single();
//     weap.spatial_bundle.transform.translation.x = player.0.translation.x;
//     weap.spatial_bundle.transform.translation.y = player.0.translation.y + 20.;
// }

#[derive(Bundle)]
struct PlayerBundle {
    player: Player,
    rigidbody: RigidBody,
    mesh: Mesh2dHandle,
    material: Handle<ColorMaterial>,
    collider: Collider,
    restitution: Restitution,
    active_events: ActiveEvents,
    jumper: Jumper,
    velocity: Velocity,
    friction: Friction,
    spatial_bundle: SpatialBundle,

}

#[derive(Component)]
struct Player;
impl PlayerBundle {
    fn new(

    mut meshes: &mut ResMut<Assets<Mesh>>,
    mut materials: &mut ResMut<Assets<ColorMaterial>>,
    ) -> PlayerBundle {
        PlayerBundle {
            player: Player,
            rigidbody: RigidBody::Dynamic,
            // materialmeshbundle: MaterialMesh2dBundle {
            //     mesh: meshes.add(shape::Circle::new(20.).into()).into(),
            //     material: materials.add(ColorMaterial::from(Color::hex("77567A").unwrap())),
            //     ..default()
            // },
            mesh: meshes.add( shape::Circle::new(20.).into() ).into(),
            material: materials.add(ColorMaterial::from(Color::hex("66567A").unwrap())),
            collider: Collider::ball(20.),
            restitution: Restitution::coefficient(0.0),
            active_events: ActiveEvents::COLLISION_EVENTS,
            jumper: Jumper {
                jump_impulse: 100.,
                roll_impulse: 0.2, 
                is_jumping: false,
                jump_multiplier: 1.
            },
            velocity: Velocity {
                linvel: Vec2::new(0.0, 0.0),
                angvel: 0.2,
            },
            friction: Friction::coefficient(2.0),
            spatial_bundle: SpatialBundle::default(),
        }

}
}



#[derive(Component)]
struct Jumper {
    jump_impulse: f32,
    roll_impulse: f32,
    is_jumping: bool,
    jump_multiplier: f32,
}
#[derive(Component)]
struct Weapon {
    pbr_bundle: PbrBundle
}


impl Weapon {
    fn new(

    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<ColorMaterial>>,
    ) -> Weapon {
        Weapon {
            pbr_bundle: PbrBundle {
                mesh: meshes.add(Mesh::from(shape::Cube { size: 1.0 })),
                material: materials.add(ColorMaterial::from(Color::rgb(0.8, 0.7, 0.6)).into()),
                transform: Transform::from_xyz(0.0, 0.5, 0.0),
                ..default()
            }
        }

    }
}


